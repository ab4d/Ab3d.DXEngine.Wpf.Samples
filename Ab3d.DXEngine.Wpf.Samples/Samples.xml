<?xml version="1.0" encoding="utf-8" ?>
<Samples>

  <Sample Page="Other/IntroductionPage.xaml" IsTitle="True" Title="Ab3d.DXEngine Introduction"/>
  <Sample Page="ModelViewer/ModelViewerSample.xaml" Title="Model viewer" />

  <Sample IsSeparator="True" />
  <Sample Page="PowerToys/PowerToysIntroPage.xaml" IsTitle="True" Title="Basic use with Ab3d.PowerToys"/>
  <Sample Page="PowerToys/AllVisualsSample.xaml" Title="All Visuals3D Objects" Description=""/>
  <Sample Page="PowerToys/SphereVisual3DSample.xaml" Title="SphereVisual3D Sample" Description=""/>
  <Sample Page="PowerToys/TextBlockVisual3DSample.xaml" Title="TextBlockVisual3D Sample" Description=""/>
  <Sample Page="PowerToys/Lines3DSample.xaml" Title="Lines3D Sample" Description=""/>
  <Sample Page="PowerToys/LineCapsSample.xaml" Title="Lines caps sample" IsNew="True" Description=""/>
  <Sample Page="PowerToys/AssimpWpfImporterSample.xaml" Title="AssimpWpfImporter" IsUpdated="True" UpdateInfo="Using new Assimp library v5.3.1.&#x0a;Also added support for reading file names with non-ascii characters." Description="This sample is almost the same as the sample in the Ab3d.PowerToys samples project but because it uses Ab3d.DXEngine it can be used to load much more complex 3D objects.\nThe only change in this sample is that it support setting line's depth bias so that the wireframe lines are much better visible (this is possible only with Ab3d.DXEngine)."/>
  <Sample Page="PowerToys/DucksLakeDemo.xaml" Title="Ducks lake demo" Description="This sample is the same as the sample in the Ab3d.PowerToys samples project - the only difference is that here the Viewport3D is enclosed inside DXViewportView (adding 3 lines into XAML) and that \bVarianceShadowRenderingProvider\b is created in code to show shadows."/>
  <Sample Page="PowerToys/Plot3DSample.xaml" Title="3D Plot sample" Description="This sample is the same as the sample in the Ab3d.PowerToys samples project, except that it can use \!proper LineDepthBias\! and can be rendered by super-sampling that can produce \!super-smooth 3D lines\!."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEnginePerformance/DXEnginePerformanceIntroPage.xaml" IsTitle="True" Title="Extreme performance"/> <!-- Instancing, 3D lines, point cloud -->

  <Sample Page="DXEnginePerformance/MultiThreadingSample.xaml" Title="Multi-threading and caching" SeeAlso="P_Ab3d_DirectX_DXScene_MaxBackgroundThreadsCount;P_Ab3d_DirectX_DXScene_IsCachingCommandLists" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/InstancedMeshGeometry3DTest.xaml" Title="Instanced MeshGeometry3D" SeeAlso="T_Ab3d_Visuals_InstancedMeshGeometryVisual3D" Description="This sample shows how to use \bInstancedMeshGeometryVisual3D\b to render incredible amount of 3D meshes with using hardware instancing. Each instance can be rendered with its own color and its own transformation matrix (defines instance position, scale and rotation). Instancing greatly improves performance because there is very little CPU overhead when rendering objects (only one draw call for all instances).\n\bNOTE:\b This sample is using PresentationType set to DirectXOverlay. This can greatly improve performance of rendering instancing because graphic card can render in the background. With DirectXImage, the CPU needs to wait until graphics card finishes rendering and then can send the rendered image to the WPF composition engine. A drawback of DirectXOverlay is that no WPF object can be drawn over 3D scene."/>
  <Sample Page="DXEnginePerformance/InstanceModelGroupVisual3DTest.xaml" Title="Instanced Model3DGroup" SeeAlso="T_Ab3d_Visuals_InstancedModelGroupVisual3D" Description="This sample shows how to use \bInstancedModelGroupGeometryVisual3D\b to render many instances of Model3DGroup models."/>
  <Sample Page="DXEnginePerformance/InstancedArrowsSample.xaml" Title="Instanced animated arrows" Description="" />
  <Sample Page="DXEnginePerformance/InstancedTextNodeSample.xaml" Title="InstancedTextNode sample" IsUpdated="True" UpdateInfo="Added SetWorldMatrix and SetOrientation to InstancedText object (allow changing rotation, scale and position of the text). Set scene type to 'Simple demo scene' to see the change." SeeAlso="T_Ab3d_DirectX_Models_InstancedTextNode" Description="InstancedTextNode can be used to render millions of characters. The 'Simple demo scene' shows how to use and change texts that are rendered by InstancedTextNode. Select other scene types to show how good the performance of InstancedTextNode is when rendering many characters." />
  <Sample Page="DXEnginePerformance/SolidColorInstanceRendering.xaml" Title="Solid-color instance rendering" Description=""/>
  <Sample Page="DXEnginePerformance/ScreenSpaceScaledInstancing.xaml" Title="Screen-space scaled instancing" Description="" />
  <Sample Page="DXEnginePerformance/InstanceWorldMatrixSamples.xaml" Title="Instance World matrix samples" Description="" />
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/PixelRenderingSample.xaml" Title="Pixels rendering" SeeAlso="T_Ab3d_Visuals_PixelsVisual3D" Description=""/>
  <Sample Page="DXEnginePerformance/PixelRenderingOptionsSample.xaml" Title="Pixels rendering options" SeeAlso="T_Ab3d_Visuals_PixelsVisual3D" Description=""/>
  <Sample Page="DXEnginePerformance/OptimizedPointCloud.xaml" Title="Optimized Point cloud" SeeAlso="T_Ab3d_DirectX_OptimizedPointMesh_1" Description=""/>
  <Sample Page="DXEnginePerformance/ColoredPointCloud.xaml" Title="Colored Point cloud" Description=""/>
  <Sample Page="DXEnginePerformance/MouseControllerForPointCloud.xaml" Title="Mouse controller for PointCloud" Description="This sample shows how to derive your own class from MouseCameraController and override its GetRotationCenterPositionFromMousePosition method. This way it is possible to get the 2D mouse position and provide the 3D position from the point cloud data from the closest position. This process is highly optimized. This way the rotate around mouse position, zoom to mouse position and movement speed work also on point cloud data."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/LinePerformanceSample.xaml" Title="Lines performance" IsUpdated="True" UpdateInfo="Show initialization performance and other line types" SeeAlso="P_Ab3d_DirectX_DXScene_UseGeometryShaderFor3DLines;P_Ab3d_DirectX_DXScene_RenderAntialiased3DLines;P_Ab3d_DirectX_DXScene_HardwareAccelerate3DLines" Description="Lines performance sample shows the performance differences of different types of 3D lines and rendering techniques."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineVisuals/DXEngineVisualsIntroPage.xaml" IsTitle="True" Title="Improved visuals"/> <!-- Shadows, environment mapping, PBR -->

  <Sample Page="DXEngineVisuals/GraphicsProfilesSample.xaml" Title="GraphicsProfiles sample" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/AdvancedEdgeLinesSample.xaml" Title="Advanced Edge lines" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="PhysicallyBasedRendering/PBRPropertiesSample.xaml" Title="PBR properties" SeeAlso="T_Ab3d_DirectX_Materials_PhysicallyBasedMaterial" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRModelViewer.xaml" Title="PBR model viewer" SeeAlso="T_Ab3d_DirectX_Materials_PhysicallyBasedMaterial" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRRobotModel.xaml" Title="PBR robot model" Description="The version that is part of the standard samples package uses textures that are scaled down to reduce the size of the package. To get full size 4k textures see the 'get 4k textures.txt' file."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/ShadowRenderingSample.xaml" Title="Shadow rendering" SeeAlso="T_Ab3d_DirectX_VarianceShadowRenderingProvider" Description="The standard shadow rendering in Ab3d.DXEngine is provided with the \bVarianceShadowRenderingProvider\b. It uses a variance shadow mapping algorithm that can render nice soft shadows with minimal artifacts (compared to some other shadow rendering techniques). The shadows can be rendered to all 3D objects.\nIn this algorithm, the whole 3D scene is rendered from the light's position into a special texture - a shadow map. The values in this texture do not represent object colors but float values that represent distances from the light. Because the shadow information for the whole 3D scene (not only for visible part) is written into one texture, the resolution of the shadow depends on the size of the shadow texture and the size of the 3D scene. Sometimes it is desirable to have a more blurry shadow. But other times, especially in technical applications, users want to have more precise shadows. To increase the shadow resolution, the shadow texture size needs to be increased (with ShadowMapSize property), or the size of the whole 3D scene needs to be decreased. For example, if your 3D objects are only a fraction of the size of a big plane, then the resolution would be significantly improved when the plane's size is reduced.\nVarianceShadowRenderingProvider supports shadow from directional and spot lights. Point lights are not supported."/>
  <Sample Page="DXEngineVisuals/PlanarShadows.xaml" Title="Planar shadows" SeeAlso="T_Ab3d_DirectX_PlanarShadowRenderingProvider" Description="Planar shadow rendering is the second shadow rendering technique in Ab3d.DXEngine. It is provided by PlanarShadowRenderingProvider and can render shadow to a 3D plane. Its advantage over VarianceShadowRenderingProvider is that it can render sharp shadows that do not loose precision even when user zoom into the shadow. It is also much faster to render. The shadows are rendered with applying a shadow matrix to all objects. This matrix flatten all the objects so that they have no height and become only a 2D shape of the object's shadow. That shape is then rendered a 3D object on top of the plane.\nTo support clipping to plane's bounds by the GPU (when using Ab3d.PowerToys this need to be done in software) and to prevent rendering some parts of the shadow multiple times, a DirectX stencil buffer is used.\nDisadvantages of PlanarShadowRenderingProvider are that it can render shadows only to a 3D plane, it cannot render soft shadows, shadows are rendered for object behind the plane or point light, some objects that lie on the plane or are very close to the plane may get slightly invalid shadow.\nIt is also possible to render planar shadows without PlanarShadowRenderingProvider and with using only PlanarShadowMeshCreator from Ab3d.PowerToys but this does not provide hardware accelerated shadows rendering (shadow object need to be created on the CPU) and cannot render transparent shadows correctly."/>
  <Sample Page="DXEngineVisuals/PlanarShadowsCustomization.xaml" Title="Planar shadows customization" Description="This sample shows some of the possibilities to customize rendering planar shadows."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/LineDepthBiasSample.xaml" Title="Line depth bias" Description="This sample shows how to prevent z-fighting artifacts that may appear when 3D lines are rendered on top of 3D solid models. In this case the lines appear disconnected and fuzzy because sometimes they are on top of solid objects and sometimes they are inside solid objects. In Ab3d.DXEngine this can be solved by applying \!LineDepthBias\! and \!LineDynamicDepthBiasFactor\!. This moves the 3D lines closer to the camera. (see comments in code for more info).\r\n\r\nIn this sample you can observe that when unchecking the 'Use dynamic bias' CheckBox, you can observe that when a small depth bias is used, this is enough for the closer box but does not work with the box that is far away. Using a bigger depth bias works well for the box far away, but causes lines that should be hidden to appear. Using dynamic depth bias solves this problem, but you need to set the correct depth bias."/>
  <Sample Page="DXEngineVisuals/SpecialLineRendering.xaml" Title="Special line rendering" SeeAlso="T_Ab3d_DirectX_DXAttributeType;T_Ab3d_DirectX_Extensions" Description=""/>
  <Sample Page="DXEngineVisuals/LinesWithPatternSample.xaml" Title="Lines with pattern" SeeAlso="T_Ab3d_DirectX_DXAttributeType;T_Ab3d_DirectX_Extensions" Description="This sample shows how to render lines with patterns.\r\n\bLinePattern\b is an int value that defines the 16 bit int value that defines the line pattern - if bit is 1 then line is drawn, when 0 line is not drawn. Note that the lowest bit is rendered first so the patten value needs to be read from right to left. For example, line with pattern 0xF0F0 will starts with empty part (4 empty bits) and then 4 full parts will be rendered.\r\n\bLinePatternScale\b is a float value that sets the pattern scale factor. Value 1 does not scale the pattern. Values bigger then 1 increase the pattern length; values smaller then 1 decrease the pattern length (making it more dense).\r\n\bLinePatternOffset\b is a float value that sets a pattern offset. This value is usually between 0 and 1 - 0 value means no offset, 1 means offset for the whole patter which is the same as no offset. Value 0.1 means that the line will begin with the pattern advanced by 10%, 1/16 means that the pattern is offset by one bit.\r\n\r\n\bLimitations:\b\r\nLine pattern is not supported on polylines, other connected lines and lines with arrows. To render line patterns on polylines, you will need to convert them to MultiLineVisual3D or other disconnected line type."/>
  <Sample Page="DXEngineVisuals/ColoredLinesSample.xaml" Title="Colored lines" SeeAlso="T_Ab3d_DirectX_ScreenSpaceLineNode;T_Ab3d_DirectX_Materials_LineMaterial" Description="This sample shows how to render lines with different start and end colors.\n\nBoth multi-line and poly-line use the same positions and colors array. The difference is that with multi-lines the lines are not connected and each line is defined by two positions. With poly-lines the lines are connected and one line's end position is the start positions of the next line."/>
  <Sample Page="DXEngineVisuals/WireframeRenderingSample.xaml" Title="Wireframe rendering" Description=""/>
  <Sample Page="DXEngineVisuals/ObjectOutlinesRenderingSample.xaml" Title="Object outlines rendering" SeeAlso="T_Ab3d_DirectX_Effects_SolidColorEffect;T_Ab3d_DirectX_PostProcessing_ExpandPostProcess;T_Ab3d_DirectX_PostProcessing_SoberEdgeDetectionPostProcess" Description=""/>
  <Sample Page="DXEngineVisuals/GlobalLineThicknessFactorSample.xaml" Title="GlobalLineThicknessFactor" Description="When showing wireframe lines and when the camera distance is big, then the lines may hide the solid part of the model. This can be prevented by dynamically adjusting the line thickness based in the camera distance. The easiest way to do this is by using ThickLineEffect.GlobalLineThicknessFactor property that specifies a value that is multiplied by each line thickness that is rendered by the ThickLineEffect."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/TransparencySortingTypesSample.xaml" Title="Transparency sorting types" Description=""/>
  <Sample Page="DXEngineVisuals/TransparencySortingPerformanceSample.xaml" Title="Transparency sorting performance" SeeAlso="P_Ab3d_DirectX_DXScene_IsTransparencySortingEnabled;\@TransparencySorter (from Ab3d.PowerToys):https://www.ab4d.com/help/PowerToys/html/T_Ab3d_Utilities_TransparencySorter.htm|" Description="This sample is showing performance of different options to sort transparent objects (see 'Transparency problem' sample in Ab3d.PowerToys sample for more info why transparency sorting is needed).\n\n\bNote that by default transparency sorting is disabled!\nTo enable it set DXViewportView.IsTransparencySortingEnabled property to true.\b"/>
  <Sample Page="DXEngineVisuals/AlphaClippingSample.xaml" Title="Alpha clipping" SeeAlso="T_Ab3d_DirectX_DXAttributeType;T_Ab3d_DirectX_Extensions" Description=""/>
  <Sample Page="DXEngineVisuals/TrianglesSortingSample.xaml" Title="Triangles sorting" Description="When a semi-transparent model has a complex geometry and you want to see the inner side of the model, then it may be needed to sort the triangles so that triangles that are farther away from the camera are rendered first"/>
  <Sample Page="DXEngineVisuals/XRayMaterialSample.xaml" Title="XRay sample" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/SupersamplingSample.xaml" Title="Supersampling" SeeAlso="P_Ab3d_DirectX_GraphicsProfile_SupersamplingCount" Description=""/>
  <Sample Page="DXEngineVisuals/SmoothLinesSample.xaml" Title="Super-smooth lines" SeeAlso="P_Ab3d_DirectX_GraphicsProfile_SupersamplingCount" Description=""/>
  <Sample Page="DXEngineVisuals/TwoDimensionalCameraSample.xaml" Title="TwoDimensionalCamera" Description=""/>
  <Sample Page="DXEngineVisuals/TwoDimensionalCameraLineEditor.xaml" Title="2D Line editor" Description=""/>
  <Sample Page="DXEngineVisuals/SharpHorizontalAndVerticalLines.xaml" Title="Sharp horizontal &amp; vertical lines" Description="The sample shows how to render some lines so that they will be always render to screen pixel. Such horizontal and vertical lines look very sharp, but they are always rendered with 1 screen pixel thickness. They also appear dimmer when using super-sampling. See comment in code for more info."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/EnvironmentReflectionsTest.xaml" Title="Environment Reflections" SeeAlso="T_Ab3d_DirectX_DXAttributeType" Description="This sample shows how to show environmental map with various reflection factors. The teapots use the following reflection factors:\nFront left Teapot: reflectionFactor = 1.0f\nFront right Teapot: reflectionFactor = 0.5f\nBack left Teapot: reflectionFactor = new SharpDX.Color3(0.5f, 0.5f, 1.0f)\nBack right Teapot: reflectionFactor = 0.0f\n\nNOTE: It is recommended to use PBR (Physically based rendering) materials to show environment mapping."/>
  <Sample Page="DXEngineVisuals/ReflectionMapSample.xaml" Title="Reflection Map" SeeAlso="T_Ab3d_DirectX_DXAttributeType" Description="This sample shows how to use reflection map to specify the reflection level on per-pixel level.\nThe ReflectionTexture specifies the reflection factors - white areas are fully reflective, dark gray areas have almost no reflectivity and mostly show the color from diffuse texture that is shown below.\n\nTo create reflection maps you will need to have a texture that is created with unwrapping the 3D model to the texture (this will map the texture coordinates from the texture to the 3D model).\n\nNOTE: It is recommended to use PBR (Physically based rendering) materials to show environment mapping."/>
  <Sample Page="DXEngineVisuals/NormalMappingSample.xaml" Title="Normal mapping" SeeAlso="T_Ab3d_DirectX_DXAttributeType" Description="It is recommended to use PBR (Physically based rendering) materials to show environment mapping."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/TwoSidedMaterialsSample.xaml" Title="TwoSided materials" SeeAlso="T_Ab3d_DirectX_Materials_ITwoSidedMaterial;N_Ab3d_DirectX_Materials" Description="The sample shows how to use two sided materials to render front and back side of the triangles with one draw call. Compare the number of renderable items in the info TextBox when rendering 'Front and back side' and when using 'TwoSided material'.\nTwo sided material can be used on WpfMaterial, StandardMaterial, VertexColorMaterial and PhysicallyBasedMaterial.\nTo use TwoSided material on a GeometryModel3D object, set its Material and BackMaterial to the same material instance. By default this will use TwoSided material for non-transparent materials. By default the transparent materials will still be rendered two times - first back material and then front material. This produces more accurate results. This behaviour can be changed by using DXEngine's material or by changing the static DXViewportView.UseTwoSidedMaterialsForSolidObjects and DXViewportView.UseTwoSidedMaterialsForTransparentObjects Boolean fields. See also comments in the (?) tooltips for more info."/>
  <Sample Page="DXEngineVisuals/VertexColorRenderingSample.xaml" Title="VertexColorMaterial" IsUpdated="True" UpdateInfo="Show how to change the VertexColorMaterial.PositionColors" SeeAlso="T_Ab3d_DirectX_Materials_VertexColorMaterial" Description="This sample shows how to use VertexColorMaterial to render 3D model with specifying different color for each vertex."/>
  <Sample Page="DXEngineVisuals/FaceColorRenderingSample.xaml" Title="FaceColorMaterial" SeeAlso="T_Ab3d_DirectX_Materials_FaceColorMaterial" Description="This sample shows how to use FaceColorMaterial to render 3D model with specifying different color for each face (triangle)."/>
  <Sample Page="DXEngineVisuals/LandscapeGeneratorSample.xaml" Title="Landscape generator" SeeAlso="T_Ab3d_DirectX_Materials_VertexColorMaterial" Description="This sample demonstrates how the Diamond Square algorithm iteratively generates natural looking landscapes.\nThe height map is rendered with using a \bspecial DXEngine's VertexColorMaterial\b that can render 3D model with specifying different color for each vertex of the model."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/PostProcessingTest.xaml" Title="Post-processing test" SeeAlso="N_Ab3d_DirectX_PostProcessing" Description="This sample show how to add post-processing effects to the rendered scene.\nWhen checked the post processes are executed in the order as their CheckBoxes are listed. To change the order of post processes, change the code in code-behind."/>
  <Sample Page="DXEngineVisuals/NormalDepthEdgeDetectionSample.xaml" Title="Advanced edge-detection" IsNew="True" Description="This sample shows an advanced edge detection technique that \buses differences in normal-depth texture to detect edges\b (instead of differences in color that are used for edge detection in previous sample). The normal-depth texture is created by the NormalDepthEffect and renders the normal vector (perpendicular to the triangle) and depth (distance) to the camera to a texture. Normal is rendered to RGB values and depth to the alpha channel. The NormalDepthEdgeDetectionPostProcessing checks if changes in normal and depth values are big enough (bigger than the threshold) and in this case draws the edge. This works better then when edges are detected only dy checking the differences in colors.\n\nTo check how depth defines edges without normals, set normal's threshold to disabled (max value). Also set the depth threshold to disabled to see when normal changes generate an edge."/>
  <Sample Page="DXEngineVisuals/StereoscopicRendering.xaml" Title="Stereoscopic Rendering" SeeAlso="T_Ab3d_DirectX_AnaglyphVirtualRealityProvider;T_Ab3d_DirectX_SplitScreenVirtualRealityProvider" Description=""/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineHitTesting/DXEngineHitTestingIntroPage.xaml" IsTitle="True" Title="Ab3d.DXEngine hit testing"/>
  <Sample Page="DXEngineHitTesting/HitTestingSample.xaml" Title="DXEngine Hit Testing" SeeAlso="M_Ab3d_DirectX_DXScene_GetClosestHitObject;M_Ab3d_DirectX_DXScene_GetAllHitObjects" Description="This sample shows how to use hit testing that is part of Ab3d.DXEngine library.\nWhen using the \bGetClosestHitObject\b method, you get the closest hit object.\nWhen using the \bGetAllHitObjects\b you get a list of all hit results (multiple hit results per one object are possible).\n\nThis sample creates a ray from the center of the 3D scene (marked with blue circle) and then executes the specified hit test method. The ray is used to show a green 3D line. All hit positions on the way are marked with red crosses."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DWrapperSample.xaml" Title="DXEventManager3DWrapper" Description="This samples shows how to wrap the standard EventManager3D from Ab3d.PowerToys library with a DXEventManager3DWrapper. This means that from the outside the class can be still used as EventManager3D but internally it uses hit testing from DXEngine."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DSample.xaml" Title="DXEventManager3D" Description="DXEventManager3D sample shows how to use \bDXEventsManager3D\b that is part of the DXEngine \binstead of EventsManager3D from Ab3d.PowerToys library\b.\nAn advantage of DXEventsManager3D is that it is much faster because it uses hit testing that is part of Ab3d.DXEngine. Also, it can be used to hit test SceneNode objects that are not created from WPF objects (for example MeshSceneNode objects).\n\nNote that when \b3D lines\b are rendered with hardware acceleration, then they cannot be used in the standard hit testing. The reason is that in this case no triangles exist on the main CPU memory that can be hit tested. In case of line with arrow, it is created on the CPU and therefore it can be hit tested. See the &quot;3D lines selector&quot; sample on how to select 3D lines with the mouse.\nSee next sample on how to use InstanceId bitmap for hit testing. See comments in that sample for comparison between those two methods."/>
  <Sample Page="DXEngineHitTesting/ManualInputEventsSample.xaml" Title="Manual input events and collision" IsNew="True" Description=""/>
  <Sample Page="DXEngineHitTesting/MeshOctTreeSample.xaml" Title="MeshOctTree sample" SeeAlso="T_Ab3d_DirectX_MeshOctTree" Description="MeshOctTree is a data structure that organizes the triangles in 3D space into multiple levels of MeshOctTreeNode objects so that the search of a triangle or a check for triangle ray intersection is very efficient. Each MeshOctTreeNodes divide its space into 8 child MeshOctTreeNodes.\n\nMeshOctTrees are used in DXEngine for very efficient hit testing of complex MeshGeometry3D objects\nFor example, when a standard hit testing is used on a 3D mesh, then the ray needs to be tested for intersection with each triangle in the mesh. Because meshes can have many triangles this can take a lot of time. When MeshOctTree are used, then first the MeshOctTree nodes that intersect the ray are found and then only the triangles in those nodes are checked for intersection with the ray. This massively decreases the number of required intersection tests. See comments in code behind for advantages and disadvantages of this method."/>
  <Sample Page="DXEngineHitTesting/InstancedObjectsHitTesting.xaml" Title="Instanced hit testing" Description="This sample shows the difference between DXEngine's and WPF hit testing on instanced objects.\nTo make WPF hit testing (used by EventsManager3D) work, you need to set IsWpfHitTestVisible property to true. In this case the DXEngine will create WPF 3D objects for each instance. Those objects are needed for WPF 3D hit testing. This greatly increases the initialization time. Also the hit testing is much slower then when using hit testing from DXEngine. The code also shows how to get the index of the selected instance."/>
  <Sample Page="DXEngineHitTesting/InstancedIdBitmapHitTesting.xaml" Title="Using InstancedId Bitmap" Description="This sample shows how hit testing on instanced object can be done by rendering instanced objects to InstanceId bitmap where it is possible to get the id of the instance from the rendered color."/>
  <Sample Page="DXEngineHitTesting/LinesSelector.xaml" Title="3D lines selector" SeeAlso="\@LineSelectorData (from Ab3d.PowerToys):https://www.ab4d.com/help/PowerToys/html/T_Ab3d_Utilities_LineSelectorData.htm|" Description="This sample shows how to use LinesSelectorData to simplify lines selection so that a line is selected when the mouse is close to the line."/>
  <Sample Page="DXEngineHitTesting/RectangularSelectionSample.xaml" Title="Rectangular selection" Description=""/>

  <Sample IsSeparator="True" />

  <Sample Page="PowerToysOther/PowerToysOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.PowerToys samples"/>
  <Sample Page="PowerToysOther/ImprovedTextBlockVisual3D.xaml" Title="Improved TextBlockVisual3D" SeeAlso="\@TextBlockVisual3D (from Ab3d.PowerToys):https://www.ab4d.com/help/PowerToys/html/T_Ab3d_Visuals_TextBlockVisual3D.htm|" Description="This sample shows additional options that are available when TextBlockVisual3D is rendered by Ab3d.DXEngine (instead of WPF 3D)."/>
  <Sample Page="PowerToysOther/HierarchyWithContentVisual3D.xaml" Title="Hierarchy with ContentVisual3D" Description="\bContentVisual3D\b is similar to WPF's ModelVisual3D object. It can also show GeometryModel3D or Model3DGroup (set to \bContent property\b) or other Visual3D objects that are added to its \bChildren collection\b.\nThe difference is that ContentVisual3D has \bIsVisible\b property that can be use to show or hide the Content and Children. When Ab3d.DXEngine is used, setting the IsVisible to false preserves the DirectX resources and therefore when IsVisible is set back to true, the object can be shown much faster."/>
  <Sample Page="PowerToysOther/ContentVisual3DSample.xaml" Title="ContentVisual3D sample" Description="This sample is showing that event complex resources (as the ship model) can be shown and hidden instantly when using ContentVisual3D.IsVisible property."/>
  <Sample Page="PowerToysOther/EventManagerDragSample.xaml" Title="EventManagerDragSample" Description="This sample is using standard EventManger3D from Ab3d.PowerToys library. The only difference is that when EventManager3D is used with DXEngine, it is recommended to set its CustomEventsSourceElement property - see comment in code behind."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/ModelMoverOverlaySample.xaml" Title="ModelMover Overlay" IsUpdated="True" UpdateInfo="Rendering ModelMoverVisual3D in OverlayRenderingQueue instead of using another Viewport3D as in Ab3d.PowerToys samples." Description="This sample shows how to use ModelMoverVisual3D in a Viewport3D over the 3D scene shown by Ab3d.DXEngine.\nThis is done with rendering the content models (boxes in this sample) with DXEngine and rendering the overlay Viewport3D (ModelMoverVisual3D) with WPF 3D.\nThe overlay Viewport3D should be rendered by WPF 3D because ModelMoverVisual3D requires mouse event support on UIElement3D objects. This is not supported when UIElement3D objects are rendered with DXEngine."/>
  <Sample Page="PowerToysOther/ModelMoverInsideObjectSample.xaml" Title="ModelMover inside object" Description="The sample shows how to use ModelMoverVisual3D inside Ab3d.DXEngine.\nTo make mouse events work with ModelMoverVisual3D, the ModelMoverVisual3D must use EventManager3D for events processing. See comments in code for more information."/>
  <Sample Page="PowerToysOther/ModelRotatorSample.xaml" Title="ModelRotatorSample" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/MultipleSceneViewSample.xaml" Title="Multiple SceneViews" Description="This sample shows how to render the same 3D objects with multiple DXViewportViews."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/AxisWith3DLabelsSample.xaml" Title="AxisWith3DLabels sample" Description=""/>
  <Sample Page="PowerToysOther/VisualBrushTest.xaml" Title="VisualBrush Test" Description="\bSmall and Big rectangles\b show how to specify different sizes for rendered bitmaps. This is done in code behind with using SetDXAttribute extension method.\n\n\bThree rectangles with green border\b show how to update the material with VisualBrush. The first rectangle does not get updated when VisualBrush is changed. The second rectangle is updated with calling Refresh method on the DXEngine's material that is used to show the WPF's Material. The third rectangle is updated with resetting the Visual property of the VisualBrush (setting the property to null and then back to its previous value). This way DXEngine can get a change notification and it can update the texture.\n\n\bRectangle with orange border\b shows how to dynamically set the size of rendered bitmap based on the size of rendered rectangle on the screen. Move the camera around and zoom with the camera to change the size of the rendered bitmap."/>
  <Sample Page="PowerToysOther/Viewport2DVisual3DTest.xaml" Title="Viewport2DVisual3D Test" Description="This sample shows that mouse and other events on Viewport2DVisual3D are not supported when rendered with Ab3d.DXEngine. The reason for this is that when rendering with Ab3d.DXEngine the Viewport3D is not shown from WPF's perspective and therefore the Viewport2DVisual3D is not getting mouse and other events. Also changes to Viewport2DVisual3D properties are not shown after it was already rendered. If you need Viewport2DVisual3D, then do not use DXEngine and use WPF rendering. To render static WPF controls inside DXEngine use VisualBrush or TextBlockVisual3D (see VisualBrush Test)."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineOther/DXEngineOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.DXEngine samples"/>

  <Sample Page="DXEngineOther/MultiDXViewportViewsSample.xaml" Title="Multi DXViewportViews" Description="This sample shows how to defined a master DXViewportView that contains the 3D scene and then add child DXViewportView objects that show the same 3D scene but provide its own cameras and can also override or change the rendering of the 3D scene."/>
  <Sample Page="DXEngineOther/ManyLightsTest.xaml" Title="Many lights test" Description="This sample shows that DXEngine can render scene with many lights. This is achieved with rendering the scene with multiple passes. But this can also have some limitations - read the comments in the ManyLightsTest.xaml.cs file for more information."/>
  <Sample Page="DXEngineOther/DDSTextureLoading.xaml" Title="DDS texture loading" Description="See code behind for more information on DDS files."/>
  <Sample Page="DXEngineOther/FrustumCullingSample.xaml" Title="Frustum culling" Description=""/>
  <Sample Page="DXEngineOther/MeshColliderSample.xaml" Title="MeshCollider sample" Description=""/>
  <Sample Page="DXEngineOther/ClosestDistanceSample.xaml" Title="Closest distance sample" Description="MeshCollider.GetClosestPosition method can be used to get the mesh vertex that is closest to the specified 3D position."/>
  <Sample Page="DXEngineOther/RenderToBitmap.xaml" Title="Render to bitmap" SeeAlso="M_Ab3d_DirectX_Controls_DXView_RenderToBitmap" Description="This sample show how to render 3D scene to bitmap without showing the 3D scene"/>
  <Sample Page="DXEngineOther/SpritesSample.xaml" Title="Sprites sample" SeeAlso="M_Ab3d_DirectX_SpriteBatch" Description="This sample shows how to use SpriteBatch object to show 2D sprites on top of a 3D scene. "/>
  <Sample Page="DXEngineOther/OverlayControlsSample.xaml" Title="Overlay WPF controls" Description="Using \!DirectXOverlay\! PresentationType has a big performance advantage because in this presentation mode the drivers and graphics card can render in the background and when the rendering is complete the graphics card can present the rendered 3D scene to its part of screen. A big disadvantage in this presentation type is that it is not possible to render WPF objects over the 3D scene.\n\nBut with using sprites, it is possible to render static WPF elements to a texture and show that in a sprite.\nIt is also possible to show dynamic WPF controls that use Viewport3D with rendering them by DXViewportView that use the same DirectX device as the main DXViewportView. This way, the rendered CameraAxisPanel can be shared with the main DXViewportView and shown by using sprites. What is more, even though the WPF controls are not shown, the mouse events are still propagated to the controls."/>
  <Sample Page="DXEngineOther/DeviceRemovedHandlerSample.xaml" Title="DeviceRemoved handler" Description="This sample demonstrates a simple way to handle a DirectX device removed event. In case of this event the code saves the state of the sample (positions of the spheres and camera properties) and restores them when the sample is reloaded.\n\nThe device removed event can happen very rarely. It happens when a graphics driver is updated while the application is running and in some other rare cases (for example in case of bug in a driver). See code comments for more info."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/BackgroundObjectsCreation.xaml" Title="Background objects creation" Description="This sample shows how to create 3D objects on the background thread (prevents locking the UI thread while the objects are created)"/>
  <Sample Page="DXEngineOther/BackgroundRenderingSample.xaml" Title="Background Rendering" Description="The sample shows how to create and render the 3D scene on the background thread. This allows rendering very complex scenes without slowing down the processing on the main UI thread. Hover over controls to see ToolTip and see code comments for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/StandardXaml.xaml" Title="Standard XAML and C#" Description="The template sample can be used to get the simple XAML and C# code that can be used as a starting point for your application that use Ab3d.DXEngine and Ab3d.PowerToys.\n\nOther samples in this project use more complex handling of DirectX graphic settings. This allows using the graphics settings set by the user of the application. It also allows overwriting the user settings by using application settings (for example when hardware rendering cannot be initialized because of a broken driver, the application settings can be set to use software rendering or WPF 3D rendering). This template samples is much more simple and provide only a few commented code snippets to specify graphic settings."/>

  <Sample IsSeparator="True" />

  <Sample Page="DXEngineAdvanced/DXEngineAdvancedIntroPage.xaml" IsTitle="True" Title="Advanced Ab3d.DXEngine usage"/> <!-- Low level usage -->
  <Sample Page="DXEngineAdvanced/CustomRenderingStep1.xaml" Title="Custom rendering step 1" Description="This sample shows how executed custom SharpDX rendering code (standard SharpDX &quot;Hello world&quot; sample) inside DXEngine. This allows mixing WPF controls with the 3D scene rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep2.xaml" Title="Custom rendering step 2" Description="This sample shows how to use \bMouseCameraController\b from Ab3d.PowerToys to control camera of the 3D objects rendered with custom SharpDX rendering code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep3.xaml" Title="Custom rendering step 3" Description="This sample shows how to create a new \bCustomActionRenderingStep\b to execute custom SharpDX rendering code. This allows mixing standard DXEngine (WPF 3D) objects and objects rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep4.xaml" Title="Custom rendering step 4" Description="This sample shows how to use \bCustomRenderableNode\b to executed custom SharpDX rendering code. See comments in code behind for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineAdvanced/ManuallyCreatedSceneNodes.xaml" Title="Manually created SceneNodes" SeeAlso="T_Ab3d_DirectX_MeshObjectNode" Description="This sample shows how to manually create SceneNodes and what are benefits of doing that (see code behind for more info).\n- \bBlue pyramid\b is created with standard Ab3d.PowerToys's \bPyramidVisual3D\b.\n- \bGreen pyramid\b is created with using \bGeometryMesh\b and \bMeshObjectNode\b.\n- \bRed, orange and yellow pyramids\b are created with using \bSimpleMes&lt;T&gt;\bh and \bMeshObjectNode\b. (T is PositionNormalTexture struct for red, float for orange and byte for yellow pyramid)\n- \bGray dragon\b is loaded with ReaderObj, then frozen and created with \bWpfOptimizedModel3DGroupNode\b.\n- AB4D logo image demonstrates how to load texture with using \bTextureLoader\b."/>
  <Sample Page="DXEngineAdvanced/ScreenSpaceLineNodeSample.xaml" Title="Creating ScreenSpaceLineNodes" SeeAlso="T_Ab3d_DirectX_ScreenSpaceLineNode" Description="This sample demonstrates how to create and update 3D lines with using low-level ScreenSpaceLineNodes. This can provide performance improvements on initialization and update. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/InstancedMeshNodeSample.xaml" Title="InstancedMeshNode sample" SeeAlso="T_Ab3d_DirectX_InstancedMeshNode" Description=""/>
  <Sample Page="DXEngineAdvanced/OptimizedTubePathSample.xaml" Title="Optimized TubePath" Description="This sample provides alternative ways to show many tube path objects. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedMeshMorphing.xaml" Title="Optimized Mesh morphing" Description=""/>
  <Sample Page="DXEngineAdvanced/CustomShaderMaterialSample.xaml" Title="Custom Shader Material" Description="This sample shows how to use custom shader to color the models based on direction of the triangle normal vector. This is done by creating a custom MeshNormalEffect and MeshNormalMaterial.\n\nThe first line of bunnies show models rendered with MeshNormalMaterial and with different ColorMask applied. The left bunny in the second line is rendered with standard WPF material. The other bunny in the second row is rendered with standard WPF material but with overridden effect so that MeshNormalEffect is used."/>
  <Sample Page="DXEngineAdvanced/CustomFogShaderEffectSample.xaml" Title="Custom fog shader effect" Description="This sample shows how to use custom shader that was designed in Ab3d.DirectX.ShaderFactory project (open and start the project to see a step by step guide about how the shader hlsl code was created).\nThe used FogShader.hlsl shader file is located in the Resources/Shaders/ folder. You can change the shader and recompile it with starting the CompileFogShader.bat. Note that if you will change the constant buffers, you also need to change the FogEffect.cs file."/>
  <Sample Page="DXEngineAdvanced/AdvancedInstanceRendering.xaml" Title="Advanced instance rendering" Description="This sample creates 3 InstancedMeshGeometry3DNode objects. The first one is used to create the DirectX instance buffer. This instance buffer is then reused by the other 2 InstancedMeshGeometry3DNode objects. Each InstancedMeshGeometry3DNode object renders different part of the instances. This is defined by setting StartInstanceIndex and InstancesCount properties. The sample also shows how to override the color from instances data and render all the instances by some other color."/>
  <Sample Page="DXEngineAdvanced/BackgroundAndOverlayRendering.xaml" Title="BG and Overlay rendering" IsUpdated="True" UpdateInfo="Using new clear depth buffer technique (see RadioButtons in 'Rendering Technique') and new hit testing that prioritize overlay objects and can lower priority of background objects (see CheckBoxes in 'Hit testing')" Description="This sample shows how to render 3D objects and lines that are always behind other 3D objects or always on top of other 3D objects. The objects and lines in \bblue\b color are always rendered behind other objects, objects and lines in \byellow\b color are rendered normally, objects and lines in \bred\b are always on top of other objects.\n\n\b3D lines\b support that with LineMaterial that defines ReadZBuffer and WriteZBuffer properties. But you also need to put them to the Background or Overlay rendering queue so that they are rendered before or after other 3D objects.\nTo render standard \b3D objects\b in background or on top of other objects, you need to create special RenderObjectsRenderingSteps that will override the DepthStencilState (set it to DepthNone) for all objects rendered in this rendering step."/>
  <Sample Page="DXEngineAdvanced/OutlinesOverObjectsSample.xaml" Title="Outlines over objects" Description="This sample uses a few advanced rendering techniques to create object outlines that are visible through other objects. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedHeightMapGeneration.xaml" Title="Optimized Height Map generation" Description="This sample shows how to generate height maps with generating vertex buffer and index buffer directly (not with first generating WPF 3D objects and then converting that into DirectX objects). The sample first generates a very simple mesh that can be shown immediately, then a background worked is started that generates the big height map and the required DirectX objects in the background thread. When the data are prepared, then the new SceneNodes are created in the main UI thread.\nNote that the generation of data is \bdelay with Thread.Sleep to simulate CPU load\b (this can be disabled with changing a const bool in a code)."/>
  <Sample Page="DXEngineAdvanced/SubMeshesSample.xaml" Title="Using SubMeshes" Description="This sample shows how to create one vertex buffer and one index buffer for many mesh geometries and how it is possible to use SubMeshes to specify different materials for different parts of this combined mesh. It also shows a very efficient way of changing materials with SumMeshes. See comments in code behind for more info."/>
  <Sample Page="DXEngineAdvanced/ObjectSelectionWithSubMeshes.xaml" Title="Selection with SubMeshes" Description="This sample shows how to efficiently use SubMeshes to show selected object with a different color. This is done with using 3 SubMeshes and changing the StartIndexLocation and IndexCount properties of SubMeshes to define with part of the mesh is shown with selection color."/>
  <Sample Page="DXEngineAdvanced/ShadedPointCloudSample.xaml" Title="ShadedPointCloud sample" Description=""/>

  <Sample IsSeparator="True" />

  <Sample Page="Other/WinFormsSample.xaml" IsTitle="True" Title="WinForms samples" Description=""/>
  <Sample Page="Other/ShaderFactoryInfo.xaml" IsTitle="True" Title="ShaderFactory solution" Description=""/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/OnlineHelp.xaml" IsTitle="True" Title="Online users and reference guide" />
  <Sample Page="Other/DXEngineSnoopTool.xaml" IsTitle="True" Title="DXEngineSnoop" Description=""/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/Ab3dPowerToysSample.xaml" IsTitle="True" Title="Ab3d.PowerToys sample project"/>

</Samples>