<?xml version="1.0" encoding="utf-8" ?>
<Samples>

  <Sample Page="Other/IntroductionPage.xaml" IsTitle="True" Title="Ab3d.DXEngine Introduction"/>

  <Sample IsSeparator="True" />
  <Sample Page="PowerToys/PowerToysIntroPage.xaml" IsTitle="True" Title="Basic use with Ab3d.PowerToys"/>
  <Sample Page="PowerToys/AllVisualsSample.xaml" Title="All Visuals3D Objects" Description=""/>
  <Sample Page="PowerToys/SphereVisual3DSample.xaml" Title="SphereVisual3D Sample" Description=""/>
  <Sample Page="PowerToys/TextBlockVisual3DSample.xaml" Title="TextBlockVisual3D Sample" Description=""/>
  <Sample Page="PowerToys/Lines3DSample.xaml" Title="Lines3D Sample" Description=""/>
  <Sample Page="PowerToys/AssimpWpfImporterSample.xaml" Title="AssimpWpfImporter" Description="This sample is almost the same as the sample in the Ab3d.PowerToys samples project but because it uses Ab3d.DXEngine it can be used to load much more complex 3D objects.\nThe only change in this sample is that it support setting line's depth bias so that the wireframe lines are much better visible (this is possible only with Ab3d.DXEngine)."/>
  <Sample Page="PowerToys/DucksLakeDemo.xaml" Title="Ducks lake demo" Description="This sample is the same as the sample in the Ab3d.PowerToys samples project - the only difference is that here the Viewport3D is enclosed inside DXViewportView (adding 3 lines into XAML) and that \bVarianceShadowRenderingProvider\b is created in code to show shadows."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEnginePerformance/DXEnginePerformanceIntroPage.xaml" IsTitle="True" Title="Extreme performance"/> <!-- Instancing, 3D lines, point cloud -->

  <Sample Page="DXEnginePerformance/MultiThreadingSample.xaml" Title="Multi-threading and caching" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/InstancedMeshGeometry3DTest.xaml" Title="Instanced MeshGeometry3D" Description="This sample shows how to use \bInstancedMeshGeometryVisual3D\b to render incredible amount of 3D meshes with using hardware instancing. Each instance can be rendered with its own color and its own transformation matrix (defines instance position, scale and rotation). Instancing greatly improves performance because there is very little CPU overhead when rendering objects (only one draw call for all instances).\n\bNOTE:\b This sample is using PresentationType set to DirectXOverlay. This can greatly improve performance of rendering instancing because graphic card can render in the background. With DirectXImage, the CPU needs to wait until graphics card finishes rendering and then can send the rendered image to the WPF composition engine. A drawback of DirectXOverlay is that no WPF object can be drawn over 3D scene."/>
  <Sample Page="DXEnginePerformance/InstanceModelGroupVisual3DTest.xaml" Title="Instanced Model3DGroup" Description="This sample shows how to use \bInstancedModelGroupGeometryVisual3D\b to render many instances of Model3DGroup models."/>
  <Sample Page="DXEnginePerformance/InstancedArrowsSample.xaml" Title="Instanced animated arrows" Description="" />
  <Sample Page="DXEnginePerformance/SolidColorInstanceRendering.xaml" Title="Solid-color instance rendering" Description=""/>
  <Sample Page="DXEnginePerformance/ScreenSpaceScaledInstancing.xaml" Title="Screen-space scaled instancing" Description="" />
  <Sample Page="DXEnginePerformance/InstanceWorldMatrixSamples.xaml" Title="Instance World matrix samples" Description="" />
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/PixelRenderingSample.xaml" Title="Pixels rendering" Description=""/>
  <Sample Page="DXEnginePerformance/PixelRenderingOptionsSample.xaml" Title="Pixels rendering options" Description=""/>
  <Sample Page="DXEnginePerformance/OptimizedPointCloud.xaml" Title="Optimized Point cloud" Description=""/>
  <Sample Page="DXEnginePerformance/ColoredPointCloud.xaml" Title="Colored Point cloud" Description=""/>
  <Sample Page="DXEnginePerformance/MouseControllerForPointCloud.xaml" Title="Mouse controller for PointCloud" Description="This sample shows how to derive your own class from MouseCameraController and override its GetRotationCenterPositionFromMousePosition method. This way it is possible to get the 2D mouse position and provide the 3D position from the point cloud data from the closest position. This process is highly optimized. This way the rotate around mouse position, zoom to mouse position and movement speed work also on point cloud data."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/PolyLinesSample.xaml" Title="PolyLines sample" Description="PolyLines sample shows that it is possible to render really many lines with hardware accelerated 3D line rendering.\nNote that by default DXEngine does not hardware accelerate rendering connected 3D lines (PolyLines and other lines that are connected to each other). This needs to be enabled with setting RenderConnectedLinesAsDisconnected to true. See code for more information."/>
  <Sample Page="DXEnginePerformance/PerformanceTest.xaml" Title="Performance Test" Description="Performance test that shows \bFPS in Windows Title\b.\nThis test uses a special rendering mode where DXEngine does not wait until WPF's Render event but starts rendering new frame immediately after one scene was rendered. This means that the scene is rendered as fast as possible.\nThis mode can be used only for performance testing because it significantly affects WPF's responsiveness (user interface is not updated - therefore FPS is rendered in title that gets updated by Windows).\nThe test is also showing how to use PerformanceAnalyzer."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineVisuals/DXEngineVisualsIntroPage.xaml" IsTitle="True" Title="Improved visuals"/> <!-- Shadows, environment mapping, PBR -->

  <Sample Page="DXEngineVisuals/AdvancedEdgeLinesSample.xaml" Title="Advanced Edge lines" IsNew="True" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="PhysicallyBasedRendering/PBRPropertiesSample.xaml" Title="PBR properties" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRModelViewer.xaml" Title="PBR model viewer" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRRobotModel.xaml" Title="PBR robot model" Description="The version that is part of the standard samples package uses textures that are scaled down to reduce the size of the package. To get full size 4k textures see the 'get 4k textures.txt' file."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/PerPixelRenderingSample.xaml" Title="Per-pixel rendering" Description=""/>
  <Sample Page="DXEngineVisuals/ShadowRenderingSample.xaml" Title="Shadow rendering" IsUpdated="True" UpdateInfo="Prevented darkening the edges of objects and added ShadowDepthBias to prevent shadow artifacts in corners" Description="The standard shadow rendering in Ab3d.DXEngine is provided with the \bVarianceShadowRenderingProvider\b. It uses a variance shadow mapping algorithm that can render nice soft shadows with minimal artifacts (compared to some other shadow rendering techniques). The shadows can be rendered to all 3D objects.\nIn this algorithm, the whole 3D scene is rendered from the light's position into a special texture - a shadow map. The values in this texture do not represent object colors but float values that represent distances from the light. Because the shadow information for the whole 3D scene (not only for visible part) is written into one texture, the resolution of the shadow depends on the size of the shadow texture and the size of the 3D scene. Sometimes it is desirable to have a more blurry shadow. But other times, especially in technical applications, users want to have more precise shadows. To increase the shadow resolution, the shadow texture size needs to be increased (with ShadowMapSize property), or the size of the whole 3D scene needs to be decreased. For example, if your 3D objects are only a fraction of the size of a big plane, then the resolution would be significantly improved when the plane's size is reduced.\nVarianceShadowRenderingProvider supports shadow from directional and spot lights. Point lights are not supported."/>
  <Sample Page="DXEngineVisuals/PlanarShadows.xaml" Title="Planar shadows" Description="Planar shadow rendering is the second shadow rendering technique in Ab3d.DXEngine. It is provided by PlanarShadowRenderingProvider and can render shadow to a 3D plane. Its advantage over VarianceShadowRenderingProvider is that it can render sharp shadows that do not loose precision even when user zoom into the shadow. It is also much faster to render. The shadows are rendered with applying a shadow matrix to all objects. This matrix flatten all the objects so that they have no height and become only a 2D shape of the object's shadow. That shape is then rendered a 3D object on top of the plane.\nTo support clipping to plane's bounds by the GPU (when using Ab3d.PowerToys this need to be done in software) and to prevent rendering some parts of the shadow multiple times, a DirectX stencil buffer is used.\nDisadvantages of PlanarShadowRenderingProvider are that it can render shadows only to a 3D plane, it cannot render soft shadows, shadows are rendered for object behind the plane or point light, some objects that lie on the plane or are very close to the plane may get slightly invalid shadow.\nIt is also possible to render planar shadows without PlanarShadowRenderingProvider and with using only PlanarShadowMeshCreator from Ab3d.PowerToys but this does not provide hardware accelerated shadows rendering (shadow object need to be created on the CPU) and cannot render transparent shadows correctly."/>
  <Sample Page="DXEngineVisuals/PlanarShadowsCustomization.xaml" Title="Planar shadows customization" Description="This sample shows some of the possibilities to customize rendering planar shadows."/>
  <Sample Page="DXEngineVisuals/LineDepthBiasSample.xaml" Title="Line depth bias" IsUpdated="True" UpdateInfo="" Description="Line depth bias sample shows how to use depth bias to offset the depth of the lines. This can prevent drawing the 3D line and solid object at the same depth which causes z-fighting (lines appear disconnected because sometimes they are on top of solid object and sometimes they are inside the solid object).\nThe samples on the left show that the correct bias value needs to be defined based on the distance of the camera to the objects (see comments in code for more info)."/>
  <Sample Page="DXEngineVisuals/SpecialLineRendering.xaml" Title="Special line rendering" Description=""/>
  <Sample Page="DXEngineVisuals/LinesWithPatternSample.xaml" Title="Lines with pattern" Description="This sample shows how to render lines with patterns.\r\n\bLinePattern\b is an int value that defines the 16 bit int value that defines the line pattern - if bit is 1 then line is drawn, when 0 line is not drawn. Note that the lowest bit is rendered first so the patten value needs to be read from right to left. For example, line with pattern 0xF0F0 will starts with empty part (4 empty bits) and then 4 full parts will be rendered.\r\n\bLinePatternScale\b is a float value that sets the pattern scale factor. Value 1 does not scale the pattern. Values bigger then 1 increase the pattern length; values smaller then 1 decrease the pattern length (making it more dense).\r\n\bLinePatternOffset\b is a float value that sets a pattern offset. This value is usually between 0 and 1 - 0 value means no offset, 1 means offset for the whole patter which is the same as no offset. Value 0.1 means that the line will begin with the pattern advanced by 10%, 1/16 means that the pattern is offset by one bit.\r\n\r\n\bLimitations:\b\r\nLine pattern is not supported on polylines, other connected lines and lines with arrows. To render line patterns on polylines, you will need to convert them to MultiLineVisual3D or other disconnected line type."/>
  <Sample Page="DXEngineVisuals/ColoredLinesSample.xaml" Title="Colored lines" Description="This sample shows how to render lines with different start and end colors.\n\nBoth multi-line and poly-line use the same positions and colors array. The difference is that with multi-lines the lines are not connected and each line is defined by two positions. With poly-lines the lines are connected and one line's end position is the start positions of the next line."/>
  <Sample Page="DXEngineVisuals/ObjectOutlinesRenderingSample.xaml" Title="Object outlines rendering" IsNew="True" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/TransparencySortingSample.xaml" Title="Transparency sorting" Description="This sample is showing different options to sort transparent objects (see 'Transparency problem' sample in Ab3d.PowerToys sample for more info why transparency sorting is needed).\n1) When \bno transparency sorting\b is used, then some objects are not visible through other objects.\n2) Using \bTransparencySorter from Ab3d.PowerToys\b sorts the objects in Model3DGroup so that Children collection first defines those that are farther away from the camera. This method works correctly but is not the fastest. First sorting WPF objects takes some time and also because the order of objects is changed, the Update part of the Ab3d.DXEngine rendering pipeline takes much more time. Also, it would be almost impossible to sort objects from different ModelVisual3D or Model3DGroup objects.\n3) Using \bsorting from Ab3d.DXEngine\b is much more efficient then using TransparencySorter. It sorts the objects inside the DXScene.TransparentRenderingQueue. Sorting is highly optimized and also does not require additional work in the Update phase.\n\bBy default transparency sorting is disabled. To enable it set DXScene.IsTransparencySortingEnabled property to true.\b To adjust the sorted order, you can use the DXScene.TransparentRenderingQueue.SortingCompleted event.\n\nWith Ab3d.DXEngine it is also possible to render transparent objects without sorting with using advanced techniques like \balpha-clipping\b and \balpha-to-coverage\b. See next sample for more info."/>
  <Sample Page="DXEngineVisuals/AlphaClippingSample.xaml" Title="Alpha clipping" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/SupersamplingSample.xaml" Title="Supersampling" IsUpdated="True" UpdateInfo="Using new super-sampling algorithm with 4x, 16x, 64x super-sampling" Description=""/>
  <Sample Page="DXEngineVisuals/SmoothLinesSample.xaml" Title="Super-smooth lines" IsNew="True" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/EnvironmentReflectionsTest.xaml" Title="Environment Reflections" Description="This sample shows how to show environmental map with various reflection factors. The teapots use the following reflection factors:\nFront left Teapot: reflectionFactor = 1.0f\nFront right Teapot: reflectionFactor = 0.5f\nBack left Teapot: reflectionFactor = new SharpDX.Color3(0.5f, 0.5f, 1.0f)\nBack right Teapot: reflectionFactor = 0.0f"/>
  <Sample Page="DXEngineVisuals/ReflectionMapSample.xaml" Title="Reflection Map" Description="This sample shows how to use reflection map to specify the reflection level on per-pixel level.\nThe ReflectionTexture specifies the reflection factors - white areas are fully reflective, dark gray areas have almost no reflectivity and mostly show the color from diffuse texture that is shown below.\n\nTo create reflection maps you will need to have a texture that is created with unwrapping the 3D model to the texture (this will map the texture coordinates from the texture to the 3D model)"/>
  <Sample Page="DXEngineVisuals/NormalMappingSample.xaml" Title="Normal mapping" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/VertexColorRenderingSample.xaml" Title="VertexColor rendering" IsNew="True" Description="This sample shows how to use VertexColorMaterial to render 3D model with specifying different color for each vertex."/>
  <Sample Page="DXEngineVisuals/LandscapeGeneratorSample.xaml" Title="Landscape generator" Description="This sample demonstrates how the Diamond Square algorithm iteratively generates natural looking landscapes.\nThe height map is rendered with using a \bspecial DXEngine's VertexColorMaterial\b that can render 3D model with specifying different color for each vertex of the model."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/PostProcessingTest.xaml" Title="Post-processing test" IsUpdated="True" UpdateInfo="Added possibility to set FilterSize for GaussianBlurPostProcess" Description="This sample show how to add post-processing effects to the rendered scene.\nWhen checked the post processes are executed in the order as their CheckBoxes are listed. To change the order of post processes, change the code in code-behind."/>
  <Sample Page="DXEngineVisuals/StereoscopicRendering.xaml" Title="Stereoscopic Rendering" Description=""/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineHitTesting/DXEngineHitTestingIntroPage.xaml" IsTitle="True" Title="Ab3d.DXEngine hit testing"/>
  <Sample Page="DXEngineHitTesting/HitTestingSample.xaml" Title="DXEngine Hit Testing" Description="This sample shows how to use hit testing that is part of Ab3d.DXEngine library.\nWhen using the \bGetClosestHitObject\b method, you get the closest hit object.\nWhen using the \bGetAllHitObjects\b you get a list of all hit results (multiple hit results per one object are possible).\n\nThis sample creates a ray from the center of the 3D scene (marked with blue circle) and then executes the specified hit test method. The ray is used to show a green 3D line. All hit positions on the way are marked with red crosses."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DWrapperSample.xaml" Title="DXEventManager3DWrapper" Description="This samples shows how to wrap the standard EventManager3D from Ab3d.PowerToys library with a DXEventManager3DWrapper. This means that from the outside the class can be still used as EventManager3D but internally it uses hit testing from DXEngine."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DSample.xaml" Title="DXEventManager3D" Description="DXEventManager3D sample shows how to use \bDXEventsManager3D\b that is part of the DXEngine \binstead of EventsManager3D from Ab3d.PowerToys library\b.\nAn advantage of DXEventsManager3D is that it is much faster because it uses hit testing that is part of Ab3d.DXEngine. Also, it can be used to hit test SceneNode objects that are not created from WPF objects (for example MeshSceneNode objects).\n\nNote that when \b3D lines\b are rendered with hardware acceleration, then they cannot be used in the standard hit testing. The reason is that in this case no triangles exist on the main CPU memory that can be hit tested. In case of line with arrow, it is created on the CPU and therefore it can be hit tested. See the &quot;3D lines selector&quot; sample on how to select 3D lines with the mouse."/>
  <Sample Page="DXEngineHitTesting/MeshOctTreeSample.xaml" Title="MeshOctTree sample" Description="MeshOctTree is a data structure that organizes the triangles in 3D space into multiple levels of MeshOctTreeNode objects so that the search of a triangle or a check for triangle ray intersection is very efficient. Each MeshOctTreeNodes divide its space into 8 child MeshOctTreeNodes.\n\nMeshOctTrees are used in DXEngine for very efficient hit testing of complex MeshGeometry3D objects\nFor example, when a standard hit testing is used on a 3D mesh, then the ray needs to be tested for intersection with each triangle in the mesh. Because meshes can have many triangles this can take a lot of time. When MeshOctTree are used, then first the MeshOctTree nodes that intersect the ray are found and then only the triangles in those nodes are checked for intersection with the ray. This massively decreases the number of required intersection tests."/>
  <Sample Page="DXEngineHitTesting/InstancedObjectsHitTesting.xaml" Title="Instanced hit testing" Description="This sample shows hit testing on instanced objects.\nTo make WPF hit testing (used by EventsManager3D) work, you need to set IsWpfHitTestVisible property to true. In this case the DXEngine will create WPF 3D objects for each instance. Those objects are needed for WPF 3D hit testing. This greatly increases the initialization time. Also the hit testing is much slower then when using hit testing from DXEngine. The code also shows how to get the index of the selected instance."/>
  <Sample Page="DXEngineHitTesting/LinesSelector.xaml" Title="3D lines selector" Description="This sample shows how to use LinesSelectorData to simplify lines selection so that a line is selected when the mouse is close to the line."/>
  <Sample Page="DXEngineHitTesting/ObjectIdRendering.xaml" Title="ObjectId rendering" IsUpdated="True" UpdateInfo="Added support to render thick lines into ObjectId bitmap.&#x0a;Now it is possible to encode ObjectId into all 4 color bytes (including alpha value)" Description="This sample shows how to render the 3D scene to bitmap where each object is rendered with different color that represents the object rendering queue and its index. This can be used for advanced selection or visibility testing. See the code-behind for more information and for method that can translate the color back to the rendering queue and object index."/>

  <Sample IsSeparator="True" />

  <Sample Page="PowerToysOther/PowerToysOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.PowerToys samples"/>
  <Sample Page="PowerToysOther/HierarchyWithContentVisual3D.xaml" Title="Hierarchy with ContentVisual3D" IsNew="True" Description="\bContentVisual3D\b is similar to WPF's ModelVisual3D object. It can also show GeometryModel3D or Model3DGroup (set to \bContent property\b) or other Visual3D objects that are added to its \bChildren collection\b.\nThe difference is that ContentVisual3D has \bIsVisible\b property that can be use to show or hide the Content and Children. When Ab3d.DXEngine is used, setting the IsVisible to false preserves the DirectX resources and therefore when IsVisible is set back to true, the object can be shown much faster."/>
  <Sample Page="PowerToysOther/ContentVisual3DSample.xaml" Title="ContentVisual3D sample" Description="This sample is showing that event complex resources (as the ship model) can be shown and hidden instantly when using ContentVisual3D.IsVisible property."/>
  <Sample Page="PowerToysOther/EventManagerDragSample.xaml" Title="EventManagerDragSample" Description="This sample is using standard EventManger3D from Ab3d.PowerToys library. The only difference is that when EventManager3D is used with DXEngine, it is recommended to set its CustomEventsSourceElement property - see comment in code behind."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/ModelMoverOverlaySample.xaml" Title="ModelMover Overlay" Description="This sample shows how to use ModelMoverVisual3D in a Viewport3D over the 3D scene shown by Ab3d.DXEngine.\nThis is done with rendering the content models (boxes in this sample) with DXEngine and rendering the overlay Viewport3D (ModelMoverVisual3D) with WPF 3D.\nThe overlay Viewport3D should be rendered by WPF 3D because ModelMoverVisual3D requires mouse event support on UIElement3D objects. This is not supported when UIElement3D objects are rendered with DXEngine."/>
  <Sample Page="PowerToysOther/ModelMoverInsideObjectSample.xaml" Title="ModelMover inside object" Description="The sample shows how to use ModelMoverVisual3D inside Ab3d.DXEngine.\nTo make mouse events work with ModelMoverVisual3D, the ModelMoverVisual3D must use EventManager3D for events processing. See comments in code for more information."/>
  <Sample Page="PowerToysOther/ModelRotatorSample.xaml" Title="ModelRotatorSample" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/MultipleSceneViewSample.xaml" Title="Multiple SceneViews" Description="This sample shows how to render the same 3D objects with multiple DXViewportViews."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/VisualBrushTest.xaml" Title="VisualBrush Test" Description="\bSmall and Big rectangles\b show how to specify different sizes for rendered bitmaps. This is done in code behind with using SetDXAttribute extension method.\n\n\bThree rectangles with green border\b show how to update the material with VisualBrush. The first rectangle does not get updated when VisualBrush is changed. The second rectangle is updated with calling Refresh method on the DXEngine's material that is used to show the WPF's Material. The third rectangle is updated with resetting the Visual property of the VisualBrush (setting the property to null and then back to its previous value). This way DXEngine can get a change notification and it can update the texture.\n\n\bRectangle with orange border\b shows how to dynamically set the size of rendered bitmap based on the size of rendered rectangle on the screen. Move the camera around and zoom with the camera to change the size of the rendered bitmap."/>
  <Sample Page="PowerToysOther/Viewport2DVisual3DTest.xaml" Title="Viewport2DVisual3D Test" Description="This sample shows that mouse and other events on Viewport2DVisual3D are not supported when rendered with Ab3d.DXEngine. The reason for this is that when rendering with Ab3d.DXEngine the Viewport3D is not shown from WPF's perspective and therefore the Viewport2DVisual3D is not getting mouse and other events. Also changes to Viewport2DVisual3D properties are not shown after it was already rendered. If you need Viewport2DVisual3D, then do not use DXEngine and use WPF rendering. To render static WPF controls inside DXEngine use VisualBrush or TextBlockVisual3D (see VisualBrush Test)."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineOther/DXEngineOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.DXEngine samples"/>

  <Sample Page="DXEngineOther/MultiDXViewportViewsSample.xaml" Title="Multi DXViewportViews" IsNew="True" Description="This sample shows how to defined a master DXViewportView that contains the 3D scene and then add child DXViewportView objects that show the same 3D scene but provide its own cameras and can also override or change the rendering of the 3D scene."/>
  <Sample Page="DXEngineOther/ManyLightsTest.xaml" Title="Many lights test" Description="This sample shows that DXEngine can render scene with many lights. This is achieved with rendering the scene with multiple passes. But this can also have some limitations - read the comments in the ManyLightsTest.xaml.cs file for more information."/>
  <Sample Page="DXEngineOther/DDSTextureLoading.xaml" Title="DDS texture loading" Description="See code behind for more information on DDS files."/>
  <Sample Page="DXEngineOther/FrustumCullingSample.xaml" Title="Frustum culling" Description=""/>
  <Sample Page="DXEngineOther/RenderToBitmap.xaml" Title="RenderToBitmap" IsUpdated="True" UpdateInfo="Added support for super-sampling and shows how to use a new override of RenderToBitmap method that reuses the WriteableBitmap object." Description="This sample show how to render 3D scene to bitmap without showing the 3D scene"/>
  <Sample Page="DXEngineOther/DeviceRemovedHandlerSample.xaml" Title="DeviceRemoved handler" Description="This sample demonstrates a simple way to handle a DirectX device removed event. In case of this event the code saves the state of the sample (positions of the spheres and camera properties) and restores them when the sample is reloaded.\n\nThe device removed event can happen very rarely. It happens when a graphics driver is updated while the application is running and in some other rare cases (for example in case of bug in a driver). See code comments for more info."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/BackgroundObjectsCreation.xaml" Title="Background objects creation" Description="This sample shows how to create 3D objects on the background thread (prevents locking the UI thread while the objects are created)"/>
  <Sample Page="DXEngineOther/BackgroundRenderingSample.xaml" Title="Background Rendering" Description="The sample shows how to create and render the 3D scene on the background thread. This allows rendering very complex scenes without slowing down the processing on the main UI thread. Hover over controls to see ToolTip and see code comments for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/StandardXaml.xaml" Title="Standard XAML and C#" Description="The template sample can be used to get the simple XAML and C# code that can be used as a starting point for your application that use Ab3d.DXEngine and Ab3d.PowerToys.\n\nOther samples in this project use more complex handling of DirectX graphic settings. This allows using the graphics settings set by the user of the application. It also allows overwriting the user settings by using application settings (for example when hardware rendering cannot be initialized because of a broken driver, the application settings can be set to use software rendering or WPF 3D rendering). This template samples is much more simple and provide only a few commented code snippets to specify graphic settings."/>

  <Sample IsSeparator="True" />

  <Sample Page="DXEngineAdvanced/DXEngineAdvancedIntroPage.xaml" IsTitle="True" Title="Advanced Ab3d.DXEngine usage"/> <!-- Low level usage -->
  <Sample Page="DXEngineAdvanced/CustomRenderingStep1.xaml" Title="Custom rendering step 1" Description="This sample shows how executed custom SharpDX rendering code (standard SharpDX &quot;Hello world&quot; sample) inside DXEngine. This allows mixing WPF controls with the 3D scene rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep2.xaml" Title="Custom rendering step 2" Description="This sample shows how to use \bMouseCameraController\b from Ab3d.PowerToys to control camera of the 3D objects rendered with custom SharpDX rendering code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep3.xaml" Title="Custom rendering step 3" Description="This sample shows how to create a new \bCustomActionRenderingStep\b to execute custom SharpDX rendering code. This allows mixing standard DXEngine (WPF 3D) objects and objects rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep4.xaml" Title="Custom rendering step 4" Description="This sample shows how to use \bCustomRenderableNode\b to executed custom SharpDX rendering code. See comments in code behind for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineAdvanced/ManuallyCreatedSceneNodes.xaml" Title="Manually created SceneNodes" Description="This sample shows how to manually create SceneNodes and what are benefits of doing that (see code behind for more info).\n- \bBlue pyramid\b is created with standard Ab3d.PowerToys's \bPyramidVisual3D\b.\n- \bGreen pyramid\b is created with using \bGeometryMesh\b and \bMeshObjectNode\b.\n- \bRed, orange and yellow pyramids\b are created with using \bSimpleMes&lt;T&gt;\bh and \bMeshObjectNode\b. (T is PositionNormalTexture struct for red, float for orange and byte for yellow pyramid)\n- \bGray dragon\b is loaded with ReaderObj, then frozen and created with \bWpfOptimizedModel3DGroupNode\b.\n- AB4D logo image demonstrates how to load texture with using \bTextureLoader\b."/>
  <Sample Page="DXEngineAdvanced/ScreenSpaceLineNodeSample.xaml" Title="Creating ScreenSpaceLineNodes" Description="This sample demonstrates how to create and update 3D lines with using low-level ScreenSpaceLineNodes. This can provide performance improvements on initialization and update. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedTubePathSample.xaml" Title="Optimized TubePath" Description="This sample provides alternative ways to show many tube path objects. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedMeshMorphing.xaml" Title="Optimized Mesh morphing" Description=""/>
  <Sample Page="DXEngineAdvanced/CustomShaderMaterialSample.xaml" Title="Custom Shader Material" Description="This sample shows how to use custom shader to color the models based on direction of the triangle normal vector. This is done by creating a custom MeshNormalEffect and MeshNormalMaterial.\n\nThe first line of bunnies show models rendered with MeshNormalMaterial and with different ColorMask applied. The left bunny in the second line is rendered with standard WPF material. The other bunny in the second row is rendered with standard WPF material but with overridden effect so that MeshNormalEffect is used."/>
  <Sample Page="DXEngineAdvanced/CustomFogShaderEffectSample.xaml" Title="Custom fog shader effect" Description="This sample shows how to use custom shader that was designed in Ab3d.DirectX.ShaderFactory project (open and start the project to see a step by step guide about how the shader hlsl code was created).\nThe used FogShader.hlsl shader file is located in the Resources/Shaders/ folder. You can change the shader and recompile it with starting the CompileFogShader.bat. Note that if you will change the constant buffers, you also need to change the FogEffect.cs file."/>
  <Sample Page="DXEngineAdvanced/AdvancedInstanceRendering.xaml" Title="Advanced instance rendering" Description="This sample creates 3 InstancedMeshGeometry3DNode objects. The first one is used to create the DirectX instance buffer. This instance buffer is then reused by the other 2 InstancedMeshGeometry3DNode objects. Each InstancedMeshGeometry3DNode object renders different part of the instances. This is defined by setting StartInstanceIndex and InstancesCount properties. The sample also shows how to override the color from instances data and render all the instances by some other color."/>
  <Sample Page="DXEngineAdvanced/BackgroundAndOverlayRendering.xaml" Title="BG and Overlay rendering" Description="This sample shows how to render 3D objects and lines that are always behind other 3D objects or always on top of other 3D objects. The objects and lines in \bblue\b color are always rendered behind other objects, objects and lines in \byellow\b color are rendered normally, objects and lines in \bred\b are always on top of other objects.\n\n\b3D lines\b support that with LineMaterial that defines ReadZBuffer and WriteZBuffer properties. But you also need to put them to the Background or Overlay rendering queue so that they are rendered before or after other 3D objects.\nTo render standard \b3D objects\b in background or on top of other objects, you need to create special RenderObjectsRenderingSteps that will override the DepthStencilState (set it to DepthNone) for all objects rendered in this rendering step."/>
  <Sample Page="DXEngineAdvanced/OutlinesOverObjectsSample.xaml" Title="Outlines over objects" IsUpdated="True" UpdateInfo="Updated the sample so it works when super-sampling (SSAA) is used (new see code comments for more info)." Description="This sample uses a few advanced rendering techniques to create object outlines that are visible through other objects. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedHeightMapGeneration.xaml" Title="Optimized Height Map generation" IsUpdated="True" UpdateInfo="Initially show simple height map and then prepare the big height map in the background - show it when ready" Description="This sample shows how to generate height maps with generating vertex buffer and index buffer directly (not with first generating WPF 3D objects and then converting that into DirectX objects). The sample first generates a very simple mesh that can be shown immediately, then a background worked is started that generates the big height map and the required DirectX objects in the background thread. When the data are prepared, then the new SceneNodes are created in the main UI thread.\nNote that the generation of data is \bdelay with Thread.Sleep to simulate CPU load\b (this can be disabled with changing a const bool in a code)."/>
  <Sample Page="DXEngineAdvanced/SubMeshesSample.xaml" Title="Using SubMeshes" Description="This sample shows how to create one vertex buffer and one index buffer for many mesh geometries and how it is possible to use SubMeshes to specify different materials for different parts of this combined mesh. It also shows a very efficient way of changing materials with SumMeshes. See comments in code behind for more info."/>
  <Sample Page="DXEngineAdvanced/ObjectSelectionWithSubMeshes.xaml" Title="Selection with SubMeshes" Description="This sample shows how to efficiently use SubMeshes to show selected object with a different color. This is done with using 3 SubMeshes and changing the StartIndexLocation and IndexCount properties of SubMeshes to define with part of the mesh is shown with selection color."/>
  <Sample Page="DXEngineAdvanced/ShadedPointCloudSample.xaml" Title="ShadedPointCloud sample" Description=""/>

  <Sample IsSeparator="True" />

  <Sample Page="Other/WinFormsSample.xaml" IsTitle="True" Title="WinForms samples" Description=""/>
  <Sample Page="Other/ShaderFactoryInfo.xaml" IsTitle="True" Title="ShaderFactory solution" Description=""/>
  <Sample Page="Other/OculusVRSample.xaml" IsTitle="True" Title="Oculus VR support"/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/OnlineHelp.xaml" IsTitle="True" Title="Online users and reference guide" />
  <Sample Page="Other/DXEngineSnoopTool.xaml" IsTitle="True" Title="DXEngineSnoop" Description=""/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/Ab3dPowerToysSample.xaml" IsTitle="True" Title="Ab3d.PowerToys sample project"/>

</Samples>